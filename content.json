{"posts":[{"title":"","text":"title: 《关于hexo图片无法显示的一种解决方法》tags: 技术cover: images/2.png 在博客搭建完成之后，要显示图片，把图片直接引用之后发现无法显示，查了好多文章试了都不起作用，其实他们的内容都是对的，但是少了一步，所以导致了图片加载不出来。 那么我们就来看一下如何操作： 1.要添加图片，先npm install 一个hexo-asset-image的依赖 npm install https://github.com/CodeFalling/hexo-asset-image --save2.然后把config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。比如我将post_asset_folder设为true之后hexo new post &quot;first-page&quot;之后新建了一篇文章，就会同时在hexo/source/post文件夹下生成一个.md文件和一个同名文件夹，文件夹存放文章中的图片 3.把图片放到.md文件的同名文件夹”first-page”里，最后在.md文件中引用图片 ![图片描述](./包名/NO.01.001.jpg）比如我就引用作 ![](./first-page/NO.01.001.jpg)4.保存文件的修改之后，在命令行输入hexo clean,接着输入hexo g --d。在浏览器输入域名后查看相关文章，显示图片成功！！","link":"/2022/10/15/blog2/"},{"title":"《明日方舟研究》","text":"明日方舟研究PPT下载链接： 点击下载 该分享主要从属性维度 广度设计 深度设计研究明日方舟如何打造卡牌差异化，并进一步分析了如何让这种差异化深入人心——通过基础设计和活动设计两个方向讨论。 属性维度其实和市面上游戏大致差不多，生命值，攻击力，物理防御，法术抗性，攻击速度，费用，冷却。但其中的阻挡数颇有意思，这一点改变了塔防只有防御塔攻击，怪物和“建筑”缺少互动的情况（虽然在皇家守卫军中已经有军营这样的存在），但把大量“建筑“直接摆在路中间，确实是一大创新。个人认为，这是这个游戏独具一格的要点之一。同时，攻击范围的指向性，技能和天赋的加入，让维度的多样性急剧上升，也让之后容易找到下为替代，培养深度有更多发展空间。 广度设计通过不同职业和不同职业下的具体天赋，来强化差异，主要区别也就是从属性为度上来改变。当然，也有角色美术上的设计。基于这样多的属性，便可以构造出很多具有特色（翘脚）的干员，让游戏的策略性更强。 深度设计在干员本身基础属性一定比例的基础上，通过等级和精英化让其数值增强，并且对于不同星级的干员，精英化可以获得不同种类的技能。这样，也就有了深度。但也引入了一个问题，如何不让数值膨胀，让贫民玩家也有游戏体验？于是，低星易培养的干员便登场了，在树枝上明显的优势，培养的低成本，让普通玩家在主线上也有游戏体验。同时让高星卡普遍低等级数值较贫庸，并且强力ob技能也在精英化之后。如此，也就保障了初期玩家体验大致相同。此外，外援也缓解了这个问题。文章中讲到了消费上限和消费下限。如此举措，也就是保障了下限，那么如何打开上限？那么就得来到下面一章 基础设计对地图设计多条路线，来让玩家需要多套阵容。延长了养成的周期，同时理智也客观限制了玩家的发展速度，让氪金更有诱惑力。 活动设计但基础设计只是保证了普通玩家的时长和氪金，但氪佬该如何继续发展，高玩（不氪金的老玩家）又如何发展？于是，便有了所谓危机合约。通过高强度的设计，和特定高星干员技能近乎硬性的需求（因为难度越高，玩家的思路必须和设计师的思路越接近，本质上就是和这一局的设计更接近）。并且，通过高难度的成就然，也让这部分玩家有了更深的培养需求。从抽更适应版本的卡，到继续培养成长曲线已经严重下滑的干员，都是一部分。除此之外，还有皮肤，徽章等系统，让老玩家，有情怀的玩家，对某个角色有偏好的玩家，也有了氪金动机。通过关卡送原石以及危机合约并不需要打到最难便可以拿奖励这种设定，也让普通玩家有选择的余地，保证了玩家基数。","link":"/2022/10/15/blog1/"},{"title":"《vscode2022安全提示关闭》","text":"当使用vscode2022版本时，使用scanf将会出现不安全警告。但在平时学习过程中，普遍使用的是scanf。为了避免麻烦，想在所有创建的项目前加上避免warning的句子。 查阅资料后，得知，每次创建项目，实际上是打开了newc++file 使用 everything 软件 搜索文件 搜索到后，无法直接编辑。于是，先复制一份到桌面，以管理员身份运行，用记事本打开，添加 #define _CRT_SECURE_NO_WARNINGS 1 复制回原文件位置合并 之后新建项目便都有该语句啦！","link":"/2022/11/14/c-learn/"},{"title":"《C语言学习2》","text":"初识 指针int* 指针型变量，用于指向int型变量 &amp;a 取a地址 1int* p=&amp;a *p 解引用操作符——找到p指针指向的存储空间 指针型变量32位机上占4字节，64位机占8字节 结构体创建结构体类型123456789struct 复杂对象名字（Book）{ char name[20] ; short price ;}; 用struct 大括号列出该类型所有属性 结尾用；结束 创建一个结构体类型变量1struct Book book1={&quot;C语言程序设计&quot;，55}； 打印结构体类型变量属性1printf(&quot;书名:%s\\n&quot;,b1.name); //打印b1的name属性 用指针变量1234struct Book book1={&quot;C语言程序设计&quot;，55}；struct Book* pb=&amp;book1;printf(&quot;%s\\n&quot;,(*pb).name);//解引用用结构体属性输出printf(&quot;%s\\n&quot;,pb-&gt;name);//用指针直接指向name属性 strcpy: 字符串拷贝 用头文件&lt;string.h&gt; 1strcpy(目的地，&quot;需要复制的字符串&quot;) 数组名本质是指针，因此之前结构体book的name属性不能直接赋值，而是用strcpy 1strcpy(book1.name,&quot;C++&quot;)","link":"/2022/11/20/clearn2/"},{"title":"《C语言学习4》","text":"指针运算 123*p -&gt;ac[0]*(p+1) -&gt;ac[1] 指针相减是指两个指针指的位置之前差了几个放下整个该类型数据的空间 *p++ 取地址，再到下一个位置 void* 来表达不知道指向什么东西的指针 动态分布内存123#include&lt;stdlib.h&gt;int *a=(int*)malloc(n*sizeof(int));//分配n个（int）型空间，把头地址给a free(a)//用完后用free释放 free空间只能还开头的指针处 1void *p=0;//初始指针放在0，就算不用，free（p）也不会出错（因为free(0/NULL)不会出问题） 字符串定义：以0 ‘\\0’ 结尾的一串字符 ‘\\0’(字符)与’0’（Ascii码中对应的0）不同 1234&lt;string.h&gt; //头文件 char* str=&quot;Hello&quot;; //字符指针str指向叫Hello的字符数组char word[]=&quot;Hello&quot;; //字符数组叫Hellochar line[10]=&quot;Hello&quot;; //占10个字节的字符数组存放'H''e''l''l''o' '\\0' 6个字符 12&quot;Hello&quot;// “Hello”会被编译器变成一个字符数组，长度为6，末尾加0 相连两个字符串“adada” “asdasda” 会自动合并成一个 字符串常量12char*s=&quot;Hello,world!&quot;;char*s1=&quot;Hello,world!&quot;;// 两者会指向同一个位置 修改字符串，不能用指针，试图对s所指字符串做写入会导致严重错误 指针定义的字符串，在很远的地方，不能更改，只读字符串数组定义的字符串，在本地变量，可以更改 12char* str=&quot;Hello&quot;;char word[]=&quot;Hello&quot;;//把很远的只读的字符串拷贝到本地变量，因此可以更改 字符串输入输出1scanf(&quot;%s&quot;,word); 读到空格、回车 、tab为止 安全地读入 1scanf(&quot;%7s&quot;,word); 最多读入7个 若用 1char* string 定义，必须要初始化给一个指针地址 空字符串char buffer[100]=””; 空字符串，buffer[0]=’\\0’ 如果char buffer[]=’’则只有一个buffer[0] 12char a[][10] //a[]为字符串数组，每个存10个字符char *a[] //一组指针 putcharint putchar(int c); 虽然是int 但只接受一个char 像标准输出（黑框）写一个字符 getcharint gerchar(void); 从标准输入读入一个字符 返回类型是int 是为了返回EOF（-1） 字符函数 strlen strlen(const char*s) strcmp int strcmp(const char *s1,const char *s2) 比较字符串，返回： 0:s1==s2 1:s1&gt;s2 -1:s1&lt;s2 strcpy 123char *strcpy(char* restrict dst, const char*restrict str)// 把str字符串（包括0）拷贝到dst strcat strchr strstr","link":"/2022/11/21/clearn4/"},{"title":"《C语言学习3》","text":"数据类型 浮点运算的精度float有效精度7位 表示浮点数 1.345f 判定浮点数相同 ​ fabs(f1-f2)&lt;1e-12 浮点数内部表达 没特殊需要，都用double 浮点类型 float %f %f/%e double %lf %f 科学计数法表示 ±5.67e±16 浮点数可以精准表示的是离散的数 强制类型转换（int）a不是改变a，而是进行一次运算 对于sizeofsizeof (a++) ​ 是静态的，只是判定a++（括号内内容）是什么类型，并不会实际让a加 逃逸字符\\b 回到上一个位置，但不一定删除 \\t 到达下一个制表位 bool #include&lt;stdbool.h&gt; 之后就可以用bool和true和false 本质上bool还是整数，printf还是%d 逻辑运算 优先级 ! &gt; &amp;&amp; &gt; || 注意短路 条件运算符1count=(count &gt; 20)?count-10:count+10 优先级大于赋值，小于其他一切 逗号运算符优先级比赋值还低，最最最低 连接两个表达式，用右边的表达式作为结果 二进制负数-补码00000001+11111111=100000000-》00000000（多的一位会被舍掉） 对于-a 补码就是0-a 实际是2^n - a 补码+原码=溢出一个零的零 1 1111111~1 0000000 - &gt; -1 ~ -128 0 0000001~ 0 1111111 -&gt;1~127 引入unsigned unsigned char c=255; printf = 255 char c=255; printf = -1 整数的输出 %d %u %ld %lu 8进制和16进制0开头为8进制 输出%o 0x为16进制 输出%x %X （大写则输出字母为大写） 函数本地变量123{ int i=10; //i生存期作用域只在这个括号内} 函数传递的只是值，并且函数内定义的变量，出去后便会无效 数组数组定义123a[]={0}; //让程序自己判断有几个a[4]={1}; //a[0]=1 之后的自动为0a[10]={[0]=2,[2]=3,6} //a[0]=2 a[2]=3 a[3]=6 其余为0 数组大小12int a[]={1,6,8,7,9,1,2,5,6,7};number=sizeof(a)/sizeof(a[0]); //求数组个数只需要让总占内存/第一个占的内存大小 作为函数参数数组作为函数参数时： ​ 不能在[]中给出数组大小 ​ 不能再用sizeof来计算数组个数 二维数组1int a[3][5] a是三行五列的矩阵 遍历12345for(i=0;i&lt;a;i++){ for(j=0;j&lt;b;j++){ a[i][j]=i*j; }} 指针 输出地址用%p &amp; 只能对变量取地址 int* p,q //*p（p指针所代表地址上的变量）和q是 int型变量 int*p //p为指针类型（int*） 1234567891011121314151617181920212223 - `*`是单目运算，来访问指针的值所代表地址上的变量- 在函数中访问指针指着的变量，可以跳出函数改变### 指针的应用- 函数有多个输出，通过指针输出- 返回函数状态 return 返回状态 指针 返回值### 数组与指针- 函数参数里的数组，实际上是调用了数组的指针 ```c sizeof(a)=sizeof(int*) 数组变量本身(a)表达地址，无需用&amp;取地址，但数组单元(a[x])表达的是变量，需要用&amp;取地址 12int*p=a;a==&amp;a[0] []可以对数组做，也可以对指针做 对指针p p[0]=*p *可以对指针做，也可以对数组做 对数组a *a=a[0] 数组变量是常量指针，因此数组间不能互相赋值 指针是const1int* const q=&amp;i 指针指向的变量地址不能变 但可以 改变指向变量大小 1*p=26; 所指是cosnt12const int *p=&amp;i;*p=26 //ERROR! const在*后就是指针const 在*前是 指向变量const const数组 const int a[]={1,2,3,4,5,6,}; 数组内变量不可改变 因此，为了保护数组不被函数破坏，可以设置 const int a[] 指针加法char *p=ac p+1 意思是下一个变量的头所在指针地址 对","link":"/2022/11/20/clearn3/"},{"title":"《弹珠游戏》","text":"点击右下角play开始游戏 操作：右——控制右边杆子左——控制左边杆子上：控制中间杆子下：振动 规则：球通过三个粉色圈后打开终点的屏障，让小球进入黄×即可胜利点这里跳转","link":"/2022/10/15/game/"},{"title":"《游戏系统》","text":"游戏系统框架 什么是系统：将零散的东西进行有序的整理，编排形成的，具有某种确定功能的整体。（有规律性，目的性） 常见游戏系统 战斗系统 战斗模式和战斗规则 战斗数值和战斗公式 技能系统 基础系统 角色信息系统 背包系统 场景和地图 怪物和NPC 游戏主界面 成长系统 装备系统 宠物系统 坐骑系统 其他（天赋/进阶/升星） 玩法系统 PVE 副本 爬塔 野怪 PVP 竞技场 即时对战 交互系统 GVE GVG 公会 好友 个人交易 拍卖，交易所 聊天和广播 周边系统 任务 邮件 商城 运营活动 系统设置 账号注册和登录 剧情/成就 系统拆解时考虑方向： 定位 目的 结构（内部子系统相互关联，和外部的关联） 规则（输入输出，做了哪些处理） 包装 交互 体验 小结：多尝试去拆解不同游戏的系统，从以上考虑方向尽可能做到细致，有分类依据。在自己构建系统时，必须围绕核心玩法去展开，有目的地构建。考虑的方向可以从以上列出地多种方向思考。","link":"/2022/10/23/game2/"},{"title":"《C语言学习1》","text":"概要 vs概念： 项目(project) 项（main.c） 函数(main) stdio.h 原英文意义：standard input output 快捷键： F5 运行 F10 调试 ctrl+滚轮 缩放 使用控制台展示运行结果 数据类型 各种字符类型对应存储空间（字节） ​ char: 1 ​ short: 2 ​ int: 4 ​ long: 4 ​ long long: 8 ​ float: 4 ​ double: 8 局部变量和全局变量名字相同时，局部变量优先 C语言变量申明不可中途插入，只能在代码块的最头上（不过2022vs貌似可以运行） 局部变量作用域：局部变量申明所在代码块内 当想使用另外源文件定义的全局变量时，需要在当前源文件内申明extern 变量名称，然后就可以使用这个变量 括号内的变量分别对应的数字依次是0、1、2······ 字符串 char arr1[ ] = “abc”; //字符串放进字符数组 char arr2[ ] = {‘a’ , ‘b’ , ‘c’ }; //放了3个字符 但输出时因为arr2末尾没有0，还输出其他怪怪的东西 ASCII 表 函数***strlen()***计算字符串长度，且转义字符算一个字符 \\ddd 表示八进制ddd转化成十进制后对应的ASCII码表内的符号 \\xdd 表示十六进制dd转化成十进制后对应的ASCII码表内的符号 位运算 &amp;按位与 |按位或 ^ 异或（相异为1） sizeof () 计算变量/类型所占空间大小，单位字节 ​ 计算数组总站大小 ​ int arr [10]={0} ​ sizeof (arr) ====10*4 ​ 反向计算数组元数个数 ​ 总大小/该类型每个所占内存","link":"/2022/11/14/clearn1/"},{"title":"《类银河恶魔城游戏研究》","text":"名称由来 Metroidvania——银河恶魔城 来自于与 银河战士 恶魔城 结构相似的游戏 特点：游戏场景是一张上下左右延申的地图，回环相扣，又通过捷径相连 游戏玩法：寻路和探索打开新地区 玩家行为：对障碍的记忆 奖励：新的能力，道具，推动游戏进度 玩家体验：探索未知，对地图的掌控感 目标：让玩家自由探索同时，不让他们陷入迷茫和沮丧 以银河战士三部曲为例第一部优点：开创了左右延伸，回环相扣的游戏类型。用一些不能通过的障碍划分不同区域，引导玩家进行探索，在获取相关能力后才可以通过。 缺点：如图 菱形为获取特殊能力的时间点 方形为使用对应能力可以通过 可见 整个流程过于平铺，没有深度。在一开始就给予玩家过多的选择，而且这些选择并没有受到限制，导致玩家可以无需探索就去打boss，能力显得并不重要。 其次，地图指引不到位，过多的无提示暗道，在没有秘籍的情况下玩家很容易卡关。但总的来说，他开创了一个先例 第二部优点：利用鸟人雕像来指引下一个道具或者隐藏房间，如图 在一定程度上提供了引导的作用。相较于第一部没有引导，提供过多的且没有相关联的选择，第二部做了很多的限制，限制玩家探索的区域。这使得玩家对获得的技能有了更多的使用，与地图有更多的互动。减少了很多无引导的暗道。 缺点：缺点也正是优点，第二部颇有矫枉过正之意。过多的限制，导致游戏长这样 玩家几乎没有什么选择，高度线性化的路线使得一切获得的道具，和所谓的隐藏密室都失去了新鲜感，让玩家感觉更像在做任务，而非在探索。 此外，玩家需要多次返回到之前的场景，用新的能力探索之前无法进入的区域，却没有捷径提供，导致玩家得反复在同一条路上跑动，会带来无聊感 第三部第三部堪称神作。 优点： 对于限制和开放的均衡——在游戏开始使用各种障碍限制玩家的探索，从而让玩家去学习不同的技能和相应的用法。甚至设计了一个大坑，当玩家跳下去后便无法上来，只能去学习技能。 每获得一个新技能，便提供一个专门的场景让玩家使用并且习惯。当玩家学习到所有的必要技能后，让玩家重新回到出生点。此时，将探索的权力交回给玩家，玩家可以随意选择之前因为能力限制所不能探索的区域，去获得非必要能力和奖品。 而极具创新性的一点是，玩家其实在一开始便有可以替代必须获得能力的操作，例如可以用蹬墙跳替换高跳鞋。但必须通过学习地图上小动物的动作才能知道。这让玩家拥有选择的权利，可以在开始不按照限制的路线走，但新玩家一般来不及注意。这样的设计，给予游戏更丰富的可玩性和玩家多周目不同线路探索的动力。 对于隐藏房间和地图引导——安放地图装置，在开启后玩家可以看到隐藏的房间。而寻找地图本身的过程也是探索的一部分，将地图的显现变为奖励，不会让玩家觉得是在做任务。同时，隐藏房间具有明显的美术暗示，让密室不再是碰运气和不断尝试，而是加入了一些解密和观察，让玩家更投入。 那么恶魔城呢？恶魔城的后缀，来源于 恶魔城X：月下夜想曲 这款游戏参考于塞尔达，但与银河战士有很多相似处 同样也是左右上下的大地图探索，与银河战士不同的地方，包括以下几点 地图铺开速度极快，在获得基础能力后快速铺开地图，给予玩家极大的自由度。虽然也有障碍限制，但玩家可以走很多非必要路线，获得非必要道具和收集品。 故事剧情更丰富，加入推理，线索收集的部分，让玩家参与剧情中来，而非只是想通关。设计伪结局，将真结局触发的条件暗藏在偌大的地图中，只有玩家细心探索后才能破解谜题，打出大结局。 在开局的时候先让玩家体验最强状态，随后剥离。让玩家开局走一条中央枢纽，体验游戏整体地图大小。在开局给予玩家整体视角。 至于名称的由来，后来的玩家把银河战士和恶魔城所共有的特点结合起来，之后具有这些特点的游戏统称为银河恶魔城游戏。诸如 奥日 空洞骑士都属于这种类型简单的设限小关卡，引导玩家获得不同能力，传送回来重新探索的局部地图","link":"/2022/10/23/game3/"},{"title":"《关卡设计》","text":"什么是关卡？关卡设计师应当怎么做？ 关卡设计师专注于：不同的游戏空间能够带给玩家何种感受和行为 广义的关卡设计包括：功能性关卡设计 &amp; 场景美术 成为关卡设计师的唯一途径，就是制作关卡，更理想的情况下，是去制作很多很多关卡。 关卡设计师应当放大视野，关卡是空间设计、艺术、心理学、编程和文化的结合。从玩家的角度来看，关卡设计和场景美术之间并没有什么区别，任何能够影响游戏世界的东西都是关卡设计 关卡承载着历史、文化和意图，作为负责任的设计师，我们必须考虑整个游戏体验。 如何制作关卡大多数 (但不是所有) 3D关卡设计项目都包含以下工作阶段: 1. 前期制作: 规划大的创意和整体体验设计 2. 平面布局: 为关卡勾勒一个可视的2D平面图 3. 体块测试: 创建一个基本的游戏内置3D草模，并进行测试 4. 脚本: 整合事件和行为 (任务，门，按钮，Al等) 5. 场景美术: 用道具和布景装扮关卡 6. 发布: 对项目进行文档化、宣传、发布 1. 前期制作前期制作：关于计划项目的基本形状和范围。这个项目是关于什么的? 设计目标和约束是什么? 2. 平面布局平面布局是关卡的基本结构，通常表现为核心区域和元素的2D平面图。它是关于玩家可以去哪里以及他们可以做什么的视觉总结。布局图纸是一种核心的关卡设计技能，与建筑学的平面图类似，能够更详细地规划关卡。 3. 体块测试体块是关卡的粗略草图，通常使用简单的块状3D建模，并带有最小的视觉细节。目的是创建关卡的基本结构原型，这样你就可以在游戏引擎中进行测试。游戏测试可以帮助你判断原型是太小还是太大，是令人困惑还是有趣，是否有平衡性等等。 4. 脚本脚本是关于将行为、事件和游戏逻辑整合到一个关卡中。 5. 场景美术一旦你对关卡的整体形状和流程有了足够的把握，你就可以开始添加更多环境艺术或视觉细节。 从马里奥3D学地图设计不需要刻意安排教学关，而是把新的机制放在一段安全，有试错机会的地方，在地图进程中逐渐增加难度，让玩家去尝试并且熟练。 在之后的boss关卡可以再次提及之前学习的关卡，让玩家使用技巧过关，从而获得满足感和成就感。 学会“起承转合”之道——即把想让和玩家学习的点从安全的地方“起”，再从不同角度阐述用法（不同对象，不同时机，不同方向等等），逐步增加失败惩罚。最后再给予一段舒适的过程，和其他内容结合在一起。或者可以设计一个boss关，来和之前的内容串联。","link":"/2022/10/26/game4/"},{"title":"《第六次上机作业》","text":"1.问题：找错误（C How to Program, 课后习题6.5 &amp; 5.46 ） 11. #define SIZE 100 12. //啥也不是 13.//b[10]无 14//没； 15.a[1][1] 16.#define value 120 127. scanf(&quot;%s&quot;,str);//定义的是char str[5] 输入字符串hello需要6位 18. %d 19. 多了 110. [1][9] 2.阅读代码，解析代码运行过程（C How to Program, 习题6.17和6.18）12345678910111213141516171819202122232425// 迭代累加#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#define SIZE 10int main(void);int whatIsThis(const int b[], int p);int main(void){ int x; int a[SIZE] = {1,2,3,4,5,6,7,8,9,10}; x = whatIsThis(a, SIZE); printf(&quot;Result is %d\\n&quot;, x); return 0;}int whatIsThis(const int b[], int p){ if (p == 1) { return b[0]; } else { return b[p - 1] + whatIsThis(b, p -1); }} 123456789101112131415161718192021//迭代return逆序输出#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#define SIZE 10void someFunction(const int b[], int startIndex, int size);int main(void){ int a[SIZE] = { 8,3,1,2,6,0,9,7,4,5 }; printf(&quot;Answer is:\\n&quot;); someFunction(a, 0, SIZE); printf(&quot;\\n&quot;); return 0;}void someFunction(const int b[], int startIndex, int size){ if (startIndex &lt; size) { someFunction(b, startIndex + 1, size); printf(&quot;%d&quot;, b[startIndex]); }} 3.删除重复数字（C How to Program, 习题6.15和6.28）1//已做过，核心就是scanf新的值，和之前存在数组中的非重复值比较，若不同，则放在数组下一位 4.质因数分解输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;int invalid = 1;int count = 0;int checkNumber(int number);int isPrimeNumber(int number);int getPrimeFactors(int number, int array[], int size);void printPrimeFactors(int number, int array[], int size);int main(){ int number; scanf(&quot;%d&quot;, &amp;number); if (invalid == 0) { printf(&quot;invalid input\\n&quot;); return 0; } if (isPrimeNumber(number)) { printf(&quot;%d is a prime number&quot;, number); return 0; } int a[100] = { 0 }; getPrimeFactors(number, a, 100); printPrimeFactors(number, a, count);}int checkNumber(int number){ if (number &lt;= 1 || number &gt; 10000) { invalid = 0; return 0; } else { invalid = 1; return 1; }}int isPrimeNumber(int number){ for (size_t i = 2; i &lt; number; i++) { if ((number / i) == ((float)number / i)) { return 0; } else { return 1; } }}int getPrimeFactors(int number, int array[], int size){ int flag = 1; while (flag == 1) { flag = 0; for (size_t i = 2; i &lt; number; i++) { if ((number / i) == ((float)number / i)) { array[count++] = i; number /= i; flag = 1; break; } } } array[count] = number;}void printPrimeFactors(int number, int array[], int size){ printf(&quot;%d=&quot;, number); for (size_t i = 0; i &lt; size; i++) { printf(&quot;%d*&quot;, array[i]); } printf(&quot;%d&quot;, array[size]);} 4.字母随机游走程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//按一下空格，走一步//拓展什么的，懒得加了，printf下count就是了（大概率不会走死路），至于有几种选择，用flag0、1、2、3统计下即可#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include &lt;windows.h&gt;int nextway(char a[][10], int* ptx, int* pty,int count);//指明下一个位置int waytrue(char a[][10], int* ptx, int* pty, int direction);int stop = 1;int printarray(char a[][10]);void Sleep(DWORD dwMilliseconds);int main(){ char a[10][10] = {0}; for (size_t i = 0; i &lt; 10; i++) { for (size_t j = 0; j &lt; 10; j++) { a[i][j] = '-'; } } int x = 0; int y = 0; int count = 1; a[x][y] = 'A';//初始化 srand(time(NULL)); for (size_t i = 1; i &lt; 26;i++) { nextway(a, &amp;x, &amp;y, i); printarray(a); system(&quot;pause&quot;); system(&quot;cls&quot;); if (!stop) { return 0; } }}int nextway(char a[][10], int* ptx, int* pty,int count){ int flag0 = 0; int flag1 = 0; int flag2 = 0; int flag3 = 0; int flag = 0; while (flag == 0) { if (flag0 == 1 &amp;&amp; flag1 == 1 &amp;&amp; flag2 == 1 &amp;&amp; flag3 == 1) { stop = 0; return 0; } int move = rand() % 4;//0=左，1=右，2=上，3=下； switch (move) { case 0: if (waytrue(a, ptx, pty, move)) { a[*ptx][*pty-1] = 'A' + count; flag = 1; *pty -= 1; } else { flag0 = 1; } break; case 1: if (waytrue(a, ptx, pty, move)) { a[*ptx][*pty+1] = 'A' + count; flag = 1; *pty += 1; } else { flag1 = 1; } break; case 2: if (waytrue(a, ptx, pty, move)) { a[*ptx-1][*pty] = 'A' + count; flag = 1; *ptx -= 1; } else { flag2 = 1; } break; case 3: if (waytrue(a, ptx, pty, move)) { a[*ptx + 1][*pty] = 'A' + count; flag = 1; *ptx += 1; } else { flag3 = 1; } break; } } return 1;}int waytrue(char a[][10], int *ptx, int *pty, int direction){ switch (direction) { case 0: if (*pty - 1 &lt; 0) { return 0; } if (a[*ptx][*pty-1] != '-') { return 0; } return 1; break; case 1: if (*pty + 1 &gt; 9) { return 0; } if (a[*ptx][*pty+1] != '-') { return 0; } return 1; break; case 2: if (*ptx - 1 &lt; 0) { return 0; } if (a[*ptx - 1][*pty] != '-') { return 0; } return 1; break; case 3:if (*ptx + 1 &gt; 9) { return 0; } if (a[*ptx + 1][*pty] != '-') { return 0; } return 1; break; }}int printarray(char a[][10]){ for (size_t i = 0; i &lt; 10; i++) { for (size_t j = 0; j &lt; 10; j++) { printf(&quot;%c&quot;, a[i][j]); } printf(&quot;\\n&quot;); }} 5.模拟七段显示器字符的效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#define _CRT_SECURE_NO_WARNINGS 1#define MAX_DIGITS 10#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;char segments[1000][3] = { {' ','_',' '},//0-0 {'|',' ','|'}, {'|','_','|'}, {' ',' ',' '},//1-1 {' ','|',' '}, {' ','|',' '}, {' ','_',' '},//2-2 {' ','_','|'}, {'|','_',' '}, {' ','_',' '},//3-3 {' ','_','|'}, {' ','_','|'}, {' ',' ',' '},//4-4 {'|','_','|'}, {' ',' ','|'}, {' ','_',' '},//5-5 {'|','_',' '}, {' ','_','|'}, {' ','_',' '},//6-6 {'|','_',' '}, {'|','_','|'}, {' ','_',' '},//7-7 {' ',' ','|'}, {' ',' ','|'}, {' ','_',' '},//8-8 {'|','_','|'}, {'|','_','|'}, {' ','_',' '},//9-9 {'|','_','|'}, {' ','_','|'},};char digits[3][MAX_DIGITS * 4];void clearDigitsArray(void);void processDigit(int digit, int position);void printDigitsArray(void);int main(){ clearDigitsArray; printf(&quot;Enter a number:&quot;); char input; int position = 0; while ((input = getchar()) != '\\n') { if (input &gt;= '0' &amp;&amp; input &lt;= '9') { processDigit((int)(input - '0'), position); position++; } } printDigitsArray(); return 0;}void clearDigitsArray(void){ for (size_t i = 0; i &lt; 3; i++) { for (size_t j = 0; j &lt; MAX_DIGITS*4; j++) { digits[i][j] = &quot; &quot;; } }}void processDigit(int digit, int position){ for (size_t i = 0; i &lt; 3; i++) { for (size_t j = position * 4; j &lt; position *4+3 ; j++) { digits[i][j] = segments[i + digit * 3][j-position*4]; } }}void printDigitsArray(void){ for (size_t i = 0; i &lt; 3; i++) { for (size_t j = 0; j &lt; MAX_DIGITS * 4; j++) { printf(&quot;%c&quot;, digits[i][j]); } printf(&quot;\\n&quot;); }} 6.逆波兰计算器演练 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&quot;stack.h&quot;#define STACK_SIZE 100int flag = 1;int stack[STACK_SIZE];int main(){ int answer = 0; printf(&quot;Enter an RPN expression:&quot;); char ch; scanf(&quot;%c&quot;, &amp;ch); while (ch != '+' &amp;&amp; ch != '-' &amp;&amp; ch != '*' &amp;&amp; ch != '/') { if (ch != ' ') push(ch - '0'); if (flag == 0) { return 0; } scanf(&quot;%c&quot;, &amp;ch); } answer = pop(); while (ch != '\\n') { switch (ch) { case '+':answer = pop()+answer; if (flag = 0) { return 0; } break; case '-':answer = pop()-answer; if (flag = 0) { return 0; } break; case '*':answer = pop()*answer; if (flag = 0) { return 0; } break; case '/':answer = pop()/answer; if (flag = 0) { return 0; } break; case '=': break; } scanf(&quot;%c&quot;, &amp;ch); } printf(&quot;Value of the Expression:%d\\n&quot;, answer); return 0;} 7.课后作业5和课后作业6相结合1//调用下函数就好了 8.分数实验_03【原始实验7】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;int x1[3] = { 0 };int x2[3] = { 0 };int x3[3] = { 0 };int checkFraction(int fractionX[]);void printOriginalFraction(int fractionX[]);void printSimplifiedFraction(const int fractionX[]);void simplifyFraction(int fractionX[]);int getGreatestCommonDivisor(int a, int b);void sumTwoFractions(int fractionX[], int fractionY[], int fractionRst[]);void subTwoFractions(int fractionX[], int fractionY[], int fractionRst[]);int main(){ printf(&quot;Please input the first fraction:\\n&quot;); printf(&quot;signed integer part:&quot;); scanf(&quot;%d&quot;, &amp;x1[0]); printf(&quot;numerator part:&quot;); scanf(&quot;%d&quot;, &amp;x1[1]); printf(&quot;denominator part:&quot;); scanf(&quot;%d&quot;, &amp;x1[2]); if (checkFraction(x1) == 0) { printf(&quot;Error input,program terminated.\\n&quot;); return 0; } else { printf(&quot;OriginalFraction:&quot;); printOriginalFraction(x1); printSimplifiedFraction(x1); } printf(&quot;\\n&quot;); printf(&quot;Please input the second fraction:\\n&quot;); printf(&quot;signed integer part:&quot;); scanf(&quot;%d&quot;, &amp;x2[0]); printf(&quot;numerator part:&quot;); scanf(&quot;%d&quot;, &amp;x2[1]); printf(&quot;denominator part:&quot;); scanf(&quot;%d&quot;, &amp;x2[2]); if (checkFraction(x1) == 0) { printf(&quot;Error input,program terminated.\\n&quot;); return 0; } else { printf(&quot;OriginalFraction:&quot;); printOriginalFraction(x2); printSimplifiedFraction(x2); } printf(&quot;\\n&quot;); sumTwoFractions(x1, x2, x3); simplifyFraction(x3); printf(&quot;Their sum is:&quot;); printOriginalFraction(x3); subTwoFractions(x1, x2, x3); simplifyFraction(x3); printf(&quot;Their difference is:&quot;); printSimplifiedFraction(x3);}int checkFraction(int fractionX[]){ if ((fractionX[2] &lt;= 0)||(fractionX[1]&lt;=0)) { return 0; } else { return 1; }}void printOriginalFraction(int fractionX[]){ if (fractionX[1] == 0) { printf(&quot;(%d)\\n&quot;, fractionX[0]); } else { printf(&quot;(%d+%d/%d)\\n&quot;, fractionX[0], fractionX[1], fractionX[2]); }}void printSimplifiedFraction(const int fractionX[]){ int part = fractionX[0]; int flag = 1; int up = fractionX[1]; int down = fractionX[2]; if (up * down &lt; 0) { up = abs(up); down = abs(down); flag = -1; } while (up &gt;= down) { up -= down; part++; } int divid = getGreatestCommonDivisor(up, down); up /= divid; down /= divid; if (part == 0) { if (up == 0) { printf(&quot;SimplifiedFraction:0&quot;); } else { printf(&quot;SimplifiedFraction:%d/%d&quot;,up,down); } } else { if (up == 0) { printf(&quot;SimplifiedFraction:%d&quot;,part*flag); } else { printf(&quot;SimplifiedFraction:%d+%d/%d&quot;, part * flag, up, down); } }}int getGreatestCommonDivisor(int a, int b){ int greatest = 1; for (int i = 1; i &lt;= min(a, b); i++) { if ((a / i == (float)a / i) &amp;&amp; (b / i == (float)b / i)) { greatest = i; } } return greatest;}void simplifyFraction(int fractionX[]) { while (fractionX[1] &gt;= fractionX[2]) { fractionX[1] -= fractionX[2]; fractionX[0]++; } int divid = getGreatestCommonDivisor(fractionX[1], fractionX[2]); fractionX[1] /= divid; fractionX[2] /= divid;}void sumTwoFractions(int fractionX[], int fractionY[], int fractionRst[]){ fractionRst[0] = fractionX[0] + fractionY[0]; fractionRst[1] = fractionX[1] * fractionY[2] + fractionX[2] * fractionY[1]; fractionRst[2] = fractionX[2] * fractionY[2];}void subTwoFractions(int fractionX[], int fractionY[], int fractionRst[]) { fractionRst[0] = fractionX[0] - fractionY[0]; fractionRst[1] = fractionX[1] * fractionY[2] - fractionX[2] * fractionY[1]; fractionRst[2] = fractionX[2] * fractionY[2]; fractionRst[1] += fractionRst[0] * fractionRst[2]; fractionRst[0] = 0;} 9.一维数组完整应用 （参考课程示例，完成自己的数组应用小程序）12//菜单挺有意思的，就是switch废手//其他的已经做过n遍了，略略略","link":"/2022/12/16/ctask1/"},{"title":"《如何通过订阅飞机场实现翻墙并注册chatGPT》","text":"","link":"/2022/12/16/ladder/"}],"tags":[{"name":"游戏策划","slug":"游戏策划","link":"/tags/%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92/"},{"name":"C语言学习","slug":"C语言学习","link":"/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"课内作业","slug":"课内作业","link":"/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"自制游戏","slug":"自制游戏","link":"/tags/%E8%87%AA%E5%88%B6%E6%B8%B8%E6%88%8F/"}],"categories":[],"pages":[{"title":"","text":"这是联创第一个新人任务，是用github pages和hexo做的第一个博客。前前后后也花了2，3个晚上了，基本就是在csdn和百科上找资料，踩了很多坑。但最终结果还是相当满意的。之后在联创game策划组学习的一些经验，也会放上来。之后增加评论功能后，各位还请随意。","link":"/about/index.html"}]}